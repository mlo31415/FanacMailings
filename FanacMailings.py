from __future__ import annotations

from typing import Optional
from collections import defaultdict
import csv
import os
import re
import datetime

import openpyxl

from FanzineIssueSpecPackage import FanzineDate

from Settings import Settings
from HelpersPackage import FindAndReplaceBracketedText, ParseFirstStringBracketedText, SortMessyNumber, SortTitle, NormalizePersonsName, Int0, DateMonthYear
from HelpersPackage import FindIndexOfStringInList
from Log import LogError, Log, LogDisplayErrorsIfAny, LogOpen


def main():
    LogOpen("log.txt", "log-ERRORS.txt")
    if not Settings().Load("FanacMailings settings.txt", MustExist=True, SuppressMessageBox=True):
        LogError("Could not find settings file 'FanacMailings settings.txt'")
        return

    # ---------------
    # Get the list of known apas
    # Mailings is a dictionary indexed by the apa name.
    #   The value is a dictionary indexed by the mailing number as a string
    #       The valur of *that* is a MailingDev
    mailingsInfoTable: dict[str, dict[str, MailingDev]]={}
    knownApas=Settings().Get("Known APAs")
    if len(knownApas) == 0:
        LogError("Settings file 'FanacMailings settings.txt' does not contain a value for 'Known APAs' (the list of APAs we care about here)")
        return
    knownApas=[x.replace('"', '').strip() for x in knownApas.split(",")]

    # ---------------
    # for each known apa, read Joe's APA mailings data if it exists
    for apaName in knownApas:
        table=ReadXLSX(apaName)
        if table is None:
            table=ReadCSV(apaName)
            if table is None:
                table={}
        mailingsInfoTable[apaName]=table


    # ---------------
    # Get the location of the CSV source file (generated by FanacAnalyzer) out of settings and open it
    sourceCSVfile=Settings().Get("CSVSource")
    if len(sourceCSVfile) == 0:
        LogError("Settings file 'FanacMailings settings.txt' does not contain a value for CSVSource (the file generated by FanacAnalyzer)")
        return

    try:
        with open(sourceCSVfile, 'r') as csvfile:
            filereader=csv.reader(csvfile, delimiter=',', quotechar='|', quoting=csv.QUOTE_MINIMAL)
            mailingsdata=[x for x in filereader]
    except FileNotFoundError:
        LogError(f"Could not open CSV file {sourceCSVfile}")
        return

    if len(mailingsdata) < 100:
        LogError(f"There are {len(mailingsdata)} items in {sourceCSVfile} -- there should be hundreds")
        return

    mailingsheaders=mailingsdata[0]

    def initialize(headers: list[str], row: list[str], item: str) -> str:
        index=FindIndexOfStringInList(headers, item)
        if index == -1:
            return ""
        return row[index]

    #--------------------------------
    class FanzineInMailing:
        def __init__(self, headers: list[str], row: list[str]):
            self.IssueName: str=initialize(headers, row, "IssueName")
            self.Series: str=initialize(headers, row, "Series")
            self.SeriesName: str=initialize(headers, row, "SeriesName")
            self.DisplayName: str=initialize(headers, row, "DisplayName")
            self.DirURL: str=initialize(headers, row, "DirURL")
            self.PageName: str=initialize(headers, row, "PageName")
            self.FIS: str=initialize(headers, row, "FIS")
            self.Locale: str=initialize(headers, row, "Locale")
            self.PageCount: str=initialize(headers, row, "PageCount")
            self.Editor: str=initialize(headers, row, "Editor")
            self.TagList: str=initialize(headers, row, "TagList")
            self.Mailings: str=initialize(headers, row, "Mailings")
    # --- end class FanzineInMailing ---

    allFanzines: list[FanzineInMailing]=[]
    for row in mailingsdata:
        allFanzines.append(FanzineInMailing(mailingsheaders, row))


    # ---------------------------
    # Turn the data from FanacAnalyzer into a dictionary of the form dict(apa, dict(mailing, data))
    apas: dict[str, dict[str, list[FanzineInMailing]]]=defaultdict(lambda: defaultdict(list))
    for fanzine in allFanzines:
        # The mailings column is of the form   ['FAPA 20 & VAPA 23']
        mailings=fanzine.Mailings.removeprefix("['").removesuffix("']")
        mailings=[x.strip() for x in mailings.split("&")]
        for mailing in mailings:
            for apa in knownApas:
                m=re.match(f"{apa}\s(.*)$", mailing)
                if m is not None:
                    # if apa not in apas.keys():
                    #     apas[apa]={}
                    mailingnumber=m.groups()[0]
                    # if mailingnumber not in apas[apa].keys():
                    #     apas[apa][mailingnumber]=[]
                    apas[apa][m.groups()[0]].append(fanzine)

    # ------------------
    # We've slurped in all the data.  Now create the index files for each issue
    # We will create a file in the ReportsDir for each APA, and put the individual issue index pages there
    reportsdir=Settings().Get("ReportsDir")
    if len(reportsdir) == 0:
        LogError("Settings file 'FanacMailings settings.txt' does not contain a value for ReportsDir (the directory to be used for reports)")
        return
    if not os.path.exists(reportsdir):
        os.mkdir(reportsdir)

    # All the pages we generate here need the same kinds of information to be added:
    #   Page title
    #   Page metadata
    #   Updated timestamp
    def AddBoilerplate(page: str, title: str, metadata: str) -> str:
        start, mid, end=ParseFirstStringBracketedText(page, "fanac-title")
        mid=mid.replace("title of page", title)
        page=start+mid+end

        start, mid, end=ParseFirstStringBracketedText(page, "head")
        mid=mid.replace("mailing content", metadata)
        page=start+mid+end

        # Add the updated date/time
        page, success=FindAndReplaceBracketedText(page, "fanac-updated", f"Updated {datetime.datetime.now().strftime('%m/%d/%Y, %H:%M:%S')}")
        return page
    # --- end class AddBoilerplate ---


    # Read the mailing and APA template files
    templateFilename=Settings().Get("Template-Mailing")
    if len(templateFilename) == 0:
        LogError("Settings file 'FanacMailings settings.txt' does not contain a value for Template-Mailing (the name of the template file for an individual mailing page)")
        return
    try:
        with open(templateFilename, "r") as file:
            templateMailing="".join(file.readlines())
    except FileNotFoundError:
        LogError(f"Could not open the mailing template file: '{templateFilename}'")
        return

    # Read the apa template file
    templateFilename=Settings().Get("Template-APA")
    if len(templateFilename) == 0:
        LogError("Settings file 'FanacMailings settings.txt' does not contain a value for Template-APA (the template for an APA page)")
        return
    try:
        with open(templateFilename, "r") as file:
            templateApa="".join(file.readlines())
    except FileNotFoundError:
        LogError(f"Could not open the APA template file, '{templateFilename}'")
        return


    # Walk through the info from FanacAnalyzer.
    # For each APA that we found there:
    #   Create an apa HTML page listing (and linking to) all the mailing pages
    #   Create all the individual mailing pages
    for apa in apas.keys():

        # Make sure that a directory exists for that APA's html files
        if not os.path.exists(os.path.join(reportsdir, apa)):
            os.mkdir(os.path.join(reportsdir, apa))

        mailingInfo: dict[str, MailingDev]={}
        if apa in mailingsInfoTable:
            mailingInfo=mailingsInfoTable[apa]

        # Also accumulate the info needed to produce the apa page
        listOfMailings: list[str]=[]
        for mailing in apas[apa]:
            listOfMailings.append(mailing)
        # Now sort the accumulation of mailings into numerical order.
        # This will be used to create the prev/next links in individual mailing pages and also to create the APA's page
        listOfMailings=sorted(listOfMailings, key=lambda x: SortMessyNumber(x))

        # For each mailing of that APA generate a mailing page.
        for mailing in apas[apa]:

            # Do a mailing page

            # First, the top matter
            # <div><fanac-top>
            # <table class=topmatter>
            # <tr><td class=topmatter>mailing</td></tr>
            # <tr><td class=topmatter>editor</td></tr>
            # <tr><td class=topmatter>date</td></tr>
            # </table>
            # </fanac-top></div>
            mailingPage=templateMailing
            start, mid, end=ParseFirstStringBracketedText(mailingPage, "fanac-top")
            editor=""   #"editor?"
            when="" #"when?"
            if mailing in mailingInfo:
                mi=mailingInfo[mailing]
                editor=f"OE: {NormalizePersonsName(mi.Editor)}"
                when=mi.Date.FormatDate("%B %Y")
                number=mi.Number
            else:
                number=mailing
            mid=mid.replace("editor", editor)
            mid=mid.replace("date", when)
            mid=mid.replace("mailing", f"{apa} Mailing #{number}")
            mailingPage=start+mid+end

            mailingPage=AddBoilerplate(mailingPage, f"{apa}-{mailing}", f"{mailing}, {editor}, {when}, {apa}-mailing")

            # Now the bottom matter (the list of fanzines)
            newtable="<tr>\n"
            # Generate the header row, selecting only those headers which are in this dict:
            colSelectionAndOrder=["IssueName", "Editor", "PageCount"]   # The columns to be displayed in order

            newtable+="<th>Contribution</th>\n"
            newtable+="<th>Editor</th>\n"
            newtable+="<th>Pages</th>\n"
            newtable+="</tr>\n"

            # Sort the contributions into order by fanzine name
            apas[apa][mailing]=sorted(apas[apa][mailing], key=lambda x: SortTitle(x.IssueName))

            # Now generate the data rows in the mailings table
            for row in apas[apa][mailing]:
                newtable+="<tr>\n"
                if row.DirURL != "" and row.PageName != "":
                    newtable+=f"<td><a href={row.DirURL}/{row.PageName}>{row.IssueName}</a></td>\n"
                else:
                    newtable+=f"<td>&nbsp;</td>\n"
                if row.Editor != "":
                    newtable+=f"<td>{row.Editor}&nbsp;&nbsp;</td>"
                else:
                    newtable+=f"<td>&nbsp;</td>\n"
                if row.PageCount != "":
                    newtable+=f"<td>{row.PageCount}</td>\n"
                else:
                    newtable+=f"<td>&nbsp;</td>\n"
                newtable+="</tr>\n"
            newtable=newtable.replace("\\", "/")

            # Insert the new issues table into the template
            mailingPage, success=FindAndReplaceBracketedText(mailingPage, "fanac-rows", newtable)
            if not success:
                LogError(f"Could not add issues table to mailing page {templateFilename} at 'fanac-rows'")
                return

            # Insert the label for the button taking you to the previous mailing for this APA
            index=listOfMailings.index(mailing)
            buttonText=f"No previous mailing"
            link='"prev.html"'
            if index > 0:
                buttonText=f" Prev Mailing (#{listOfMailings[index-1]})"
                link=f'"{listOfMailings[index-1]}.html"'
            mailingPage, success=FindAndReplaceBracketedText(mailingPage, "fanac-PrevMailing", buttonText)
            if success:
                mailingPage=mailingPage.replace('"prev.html"', link)
            if not success:
                LogError(f"Could not change prev button text on mailing page {templateFilename} at 'fanac-PrevMailing'")
                return

            # Insert the label for the button taking you up one level to all mailings for this APA
            mailingPage, success=FindAndReplaceBracketedText(mailingPage, "fanac-AllMailings", f"All {apa} mailings")
            if not success:
                LogError(f"Could not change up to APA button text on mailing page {templateFilename} at 'fanac-AllMailings'")
                return

            # Insert the label for the button taking you to the next mailing for this APA
            index=listOfMailings.index(mailing)
            buttonText=f"No next mailing"
            link='"next.html"'
            if index < len(listOfMailings)-1:
                buttonText=f" Next Mailing (#{listOfMailings[index+1]}) "
                link=f'"{listOfMailings[index+1]}.html"'
            mailingPage, success=FindAndReplaceBracketedText(mailingPage, "fanac-NextMailing", buttonText)
            if success:
                mailingPage=mailingPage.replace('"next.html"', link)
            if not success:
                LogError(f"Could not change next button text on mailing page {templateFilename} at 'fanac-NextMailing'")
                return

            # Modify the Mailto: so that the page name appears as the subject
            mailingPage, success=FindAndReplaceBracketedText(mailingPage, "fanac-ThisPageName", f"{apa}:{mailing}")
            if not success:
                LogError(f"Could not change mailto Subject on mailing page {templateFilename} at 'fanac-ThisPageName'")
                #return

            # Write the mailing file
            with open(os.path.join(reportsdir, apa, mailing)+".html", "w") as file:
                mailingPage=mailingPage.split("/n")
                file.writelines(mailingPage)


        #------------------------------
        # Now that the mailing pages are all done, do an apa page

        # Add the APA's name at the top
        start, mid, end=ParseFirstStringBracketedText(templateApa, "fanac-top")
        mid=mid.replace("apa-name", apa)
        newAPAPage=start+mid+end

        # Add random descriptive information if a file <apa>-bumpf.txt exists.  (E.g., SAPS-bumpf.txt)
        fname=apa+"-bumpf.txt"
        if os.path.exists(fname):
            with open(fname, "r") as file:
                bumpf=file.read()
            if len(bumpf) > 0:
                start, mid, end=ParseFirstStringBracketedText(newAPAPage, "fanac-bumpf")
                if len(end) > 0:
                    mid=bumpf+"<p>"
                    newAPAPage=start+mid+end
            Log(f"Bumpf added to {apa} page")
        else:
            Log(f" No {fname} file found, so no bumpf added to {apa} page.")

        newAPAPage=AddBoilerplate(newAPAPage, f"{apa} Mailings", f"{apa} mailings")

        loc=newAPAPage.find("</fanac-rows>")
        if loc < 0:
            LogError(f"The APA template '{templateFilename}' is missing the '</fanac-rows>' indicator.")
            return
        newAPAPageFront=newAPAPage[:loc]
        newAPAPageRear=newAPAPage[loc+len("</fanac-rows>"):]

        for mailing in listOfMailings:
            editor=""   #"editor?"
            when="" #"when?"
            if mailing in mailingInfo:
                mlng=mailingInfo[mailing]
                editor=NormalizePersonsName(mlng.Editor)
                when=DateMonthYear(Int0(mlng.Date.Month), Int0(mlng.Date.Year))

            newAPAPageFront+=f"\n<tr><td><a href={mailing}.html>{mailing}</a></td><td>{when}</td><td>{editor}</td><td style='text-align: right'>{len(apas[apa][mailing])}&nbsp;&nbsp;&nbsp;&nbsp;</td></tr>"

        newAPAPage=newAPAPageFront+newAPAPageRear

        # Add counts of mailings and contributions to bottom
        start, mid, end=ParseFirstStringBracketedText(newAPAPage, "fanac-totals")
        numConts=0
        for mailing in listOfMailings:
            numConts+=len(apas[apa][mailing])

        mid=f"{len(listOfMailings)} mailings containing {numConts} individual contributions"
        newAPAPage=start+mid+end

        # Add the updated date/time
        newAPAPage, success=FindAndReplaceBracketedText(newAPAPage, "fanac-updated", f"Updated {datetime.datetime.now().strftime('%m/%d/%Y, %H:%M:%S')}>")

        # Make the mailto correctly list the apa in the subject line
        newAPAPage, success=FindAndReplaceBracketedText(newAPAPage, "fanac-APAPageMailto", f"Issue related to APA {apa}")
        if not success:
            LogError(f"The APA template '{templateFilename}' is missing the '</fanac-APAPageMailto>' indicator.")
            return

        # Write out the APA list of all mailings
        with open(os.path.join(reportsdir, apa, "index.html"), "w") as file:
            file.writelines(newAPAPage)


    #########################################################################
    # Generate the All Apas root page
    templateFilename=Settings().Get("Template-allAPAs")
    if len(templateFilename) == 0:
        LogError("Settings file 'FanacMailings settings.txt' does not contain a value for Template-allAPAs (the template for the page listing all APAs)")
        return
    try:
        with open(templateFilename, "r") as file:
            templateAllApas="".join(file.readlines())
    except FileNotFoundError:
        LogError(f"Could not open the all APAs template file, '{templateFilename}'")
        return

    templateAllApas=AddBoilerplate(templateAllApas, f"Mailings for All APAs", f"Mailings for All APAs")

    listText="&nbsp;<ul>"
    for apa in apas.keys():
        listText+=f"<li><a href='{apa}/index.html'>{apa}</a></li>\n"
    listText+="</ul>\n"
    templateAllApas, success=FindAndReplaceBracketedText(templateAllApas, "fanac-list", listText)

    with open(os.path.join(reportsdir, "index.html"), "w") as file:
        file.writelines(templateAllApas)


######################################################################

# Entry in a dictionary of mailings for an APA.
class MailingDev:
    def __init__(self, Number: str = "", Year: str = "", Month: str = "", Editor: str = ""):
        self.Number: str=Number
        self.Editor: str=Editor
        self.Prev: str=""
        self.Next: str=""

        fd=FanzineDate()
        if Month != "":
            fd.Month=Month
        if Year != "":
            fd.Year=Year
        self.Date: FanzineDate=fd

    @property
    def Year(self) -> int:
        return self.Date.Year

    @Year.setter
    def Year(self, y: int) -> None:
        self.Date.Year=y

    @property
    def Month(self) -> int:
        return self.Date.Month

    @Month.setter
    def Month(self, m: int) -> None:
        self.Date.Month=m

# --- end class MailingDev ---


def ReadCSV(apaName: str) -> Optional[dict[str, MailingDev]]:
    csvname=apaName+".csv"
    # Skip missing csv files
    if not os.path.exists(csvname):
        return None
    # Read the csv file
    try:
        with open(csvname, 'r') as csvfile:
            # Read it into a list of lists
            filereader=csv.reader(csvfile, delimiter=',', quotechar='"')
            mailingsdata=[x for x in filereader]
    except FileNotFoundError:
        LogError(f"Could not open CSV file {csvname}")
        return None
    # Separate out the header row
    mailingsheaders=mailingsdata[0]
    mailingsdata=mailingsdata[1:]

    monthCol=FindIndexOfStringInList(mailingsheaders, "Month")
    if monthCol is None:
        LogError(f"{csvname} does not contain an 'Month' column")
        return None
    yearCol=FindIndexOfStringInList(mailingsheaders, "Year")
    if yearCol is None:
        LogError(f"{csvname} does not contain an 'Year' column")
        return None
    editorCol=FindIndexOfStringInList(mailingsheaders, ["Editor", "OE"])
    if editorCol is None:
        LogError(f"{csvname} does not contain an 'Editor' column")
        return None
    mailingCol=FindIndexOfStringInList(mailingsheaders, ["Mailing", "Issue"])
    if mailingCol is None:
        LogError(f"{csvname} does not contain a 'Mailing' or an 'Issue' column")
        return None

    mailingsInfo={}
    for md in mailingsdata:
        mailingNum=md[mailingCol]
        mailingsInfo[mailingNum]=MailingDev(Number=mailingNum, Year=md[yearCol], Month=md[monthCol], Editor=md[editorCol])
    return mailingsInfo


def ReadXLSX(apaName: str) -> Optional[dict[str, MailingDev]]:
    xlsxname=apaName+".xlsx"
    # Skip missing xlsx files
    if not os.path.exists(xlsxname):
        return None
    # Read the csv file
    try:
        wb=openpyxl.load_workbook(filename=xlsxname)
    except FileNotFoundError:
        LogError(f"Could not open xlsx file {xlsxname}")
        return None


    ws=wb.active
    # Separate out the header row
    mailingsheaders=[x.value for x in ws[1]]

    monthCol=FindIndexOfStringInList(mailingsheaders, "Month")
    if monthCol is None:
        LogError(f"{xlsxname} does not contain an 'Month' column")
        return None
    yearCol=FindIndexOfStringInList(mailingsheaders, "Year")
    if yearCol is None:
        LogError(f"{xlsxname} does not contain an 'Year' column")
        return None
    editorCol=FindIndexOfStringInList(mailingsheaders, ["Editor", "OE"])
    if editorCol is None:
        LogError(f"{xlsxname} does not contain an 'Editor' column")
        return None
    mailingCol=FindIndexOfStringInList(mailingsheaders, ["Mailing", "Issue"])
    if mailingCol is None:
        LogError(f"{xlsxname} does not contain a 'Mailing' or an 'Issue' column")
        return None

    mailingsInfo={}
    for i in range(2, 10000):
        row=[x.value for x in ws[i]]
        if all([x is None for x in row]):
            break
        mailingNum=row[mailingCol]
        if type(mailingNum) is int:
            mailingNum=str(mailingNum)  # Standard is to treat mailing number as a string, because sometimes it has to be
        editor=row[editorCol]
        if editor is None:
            editor=""
        mailingsInfo[mailingNum]=MailingDev(Number=mailingNum, Year=row[yearCol], Month=row[monthCol], Editor=editor)
    return mailingsInfo


# Run main()
if __name__ == "__main__":
    main()
    LogDisplayErrorsIfAny()


